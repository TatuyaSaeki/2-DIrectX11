//===========================================================================
//!	@file	math_vector.cpp
//!	@brief	ベクトル
//===========================================================================

//===========================================================================
//	2要素ベクトル構造体
//===========================================================================

const Vector2 Vector2::ZERO(0.0f, 0.0f);
const Vector2 Vector2::ONE(1.0f, 1.0f);

const Vector2 Vector2::AXISx_(1.0f, 0.0f);
const Vector2 Vector2::AXISy_(0.0f, 1.0f);

//===========================================================================
//	３要素ベクトル構造体
//===========================================================================
const Vector3 Vector3::ZERO(0.0f, 0.0f, 0.0f);
const Vector3 Vector3::ONE(1.0f, 1.0f, 1.0f);

const Vector3 Vector3::AXISx_(1.0f, 0.0f, 0.0f);
const Vector3 Vector3::AXISy_(0.0f, 1.0f, 0.0f);
const Vector3 Vector3::AXISz_(0.0f, 0.0f, 1.0f);

//---------------------------------------------------------------------------
//! デフォルトコンストラクタ
//---------------------------------------------------------------------------
Vector2::Vector2(void)
{
}

//---------------------------------------------------------------------------
//! コンストラクタ
//---------------------------------------------------------------------------
Vector2::Vector2(f32 x, f32 y)
	: x_(x)
	, y_(y)
{
}

//---------------------------------------------------------------------------
//! 加算
//---------------------------------------------------------------------------
Vector2 Vector2::operator+(const Vector2& v) const
{
	Vector2 result;
	result.x_ = x_ + v.x_;
	result.y_ = y_ + v.y_;

	return result;
}

//---------------------------------------------------------------------------
//! 減算
//---------------------------------------------------------------------------
Vector2 Vector2::operator-(const Vector2& v) const
{
	Vector2 result;
	result.x_ = x_ - v.x_;
	result.y_ = y_ - v.y_;

	return result;
}

//---------------------------------------------------------------------------
//! 乗算
//---------------------------------------------------------------------------
Vector2 Vector2::operator*(const Vector2& v) const
{
	Vector2 result;
	result.x_ = x_ * v.x_;
	result.y_ = y_ * v.y_;

	return result;
}

//---------------------------------------------------------------------------
//! スケーリング
//---------------------------------------------------------------------------
Vector2 Vector2::operator*(f32 scale) const
{
	Vector2 result;
	result.x_ = x_ * scale;
	result.y_ = y_ * scale;

	return result;
}

//---------------------------------------------------------------------------
//! スケーリング
//---------------------------------------------------------------------------
Vector2 Vector2::operator/(f32 scale) const
{
	Vector2 result;
	f32     invScale = 1.0f / scale;
	result.x_ = x_ * invScale;
	result.y_ = y_ * invScale;

	return result;
}

//---------------------------------------------------------------------------
//!	内積
//---------------------------------------------------------------------------
f32 Vector2::dot(const Vector2& a, const Vector2& b)
{
	return (a.x_ * b.x_) + (a.y_ * b.y_);
}

//---------------------------------------------------------------------------
//!	外積
//---------------------------------------------------------------------------
f32 Vector2::cross(const Vector2& a, const Vector2& b)
{
	return a.x_ * b.y_ - a.y_ * b.x_;
}

//---------------------------------------------------------------------------
//! デフォルトコンストラクタ
//---------------------------------------------------------------------------
Vector3::Vector3()
	: x_(0.0f)
	, y_(0.0f)
	, z_(0.0f)
{
}

//---------------------------------------------------------------------------
//! コンストラクタ (xyz指定)
//---------------------------------------------------------------------------
Vector3::Vector3(f32 x, f32 y, f32 z)
{
	x_ = x;
	y_ = y;
	z_ = z;
}

//---------------------------------------------------------------------------
//! コンストラクタ
//---------------------------------------------------------------------------
Vector3::Vector3(const Vector3& v)
{
	x_ = v.x_;
	y_ = v.y_;
	z_ = v.z_;
}

//---------------------------------------------------------------------------
//! コンストラクタ
//---------------------------------------------------------------------------
Vector3::Vector3(const Vector4& v)
{
	x_ = v.x_;
	y_ = v.y_;
	z_ = v.z_;
}

//---------------------------------------------------------------------------
//! コンストラクタ
//---------------------------------------------------------------------------
Vector3::Vector3(f32 s)
{
	x_ = s;
	y_ = s;
	z_ = s;
}

//---------------------------------------------------------------------------
//!	代入
//---------------------------------------------------------------------------
Vector3& Vector3::operator=(const Vector3& v)
{
	x_ = v.x_;
	y_ = v.y_;
	z_ = v.z_;

	return *this;
}

//---------------------------------------------------------------------------
//!	代入(Vector4)
//---------------------------------------------------------------------------
Vector3& Vector3::operator=(const Vector4& v)
{
	x_ = v.x_;
	y_ = v.y_;
	z_ = v.z_;

	return *this;
}

//---------------------------------------------------------------------------
//! 正の値
//---------------------------------------------------------------------------
Vector3 Vector3::operator+() const
{
	return *this;
}

//---------------------------------------------------------------------------
//! 負の値
//---------------------------------------------------------------------------
Vector3 Vector3::operator-() const
{
	return *this * -1.0f;
}

//---------------------------------------------------------------------------
//! 加算
//---------------------------------------------------------------------------
Vector3 Vector3::operator+(const Vector3& v) const
{
	Vector3 result;
	result.x_ = x_ + v.x_;
	result.y_ = y_ + v.y_;
	result.z_ = z_ + v.z_;

	return result;
}

//---------------------------------------------------------------------------
//! 減算
//---------------------------------------------------------------------------
Vector3 Vector3::operator-(const Vector3& v) const
{
	Vector3 result;
	result.x_ = x_ - v.x_;
	result.y_ = y_ - v.y_;
	result.z_ = z_ - v.z_;

	return result;
}

//---------------------------------------------------------------------------
//! 乗算
//---------------------------------------------------------------------------
Vector3 Vector3::operator*(const Vector3& v) const
{
	Vector3 result;
	result.x_ = x_ * v.x_;
	result.y_ = y_ * v.y_;
	result.z_ = z_ * v.z_;

	return result;
}

//---------------------------------------------------------------------------
//! スケーリング
//---------------------------------------------------------------------------
Vector3 Vector3::operator*(f32 scale) const
{
	Vector3 result;
	result.x_ = x_ * scale;
	result.y_ = y_ * scale;
	result.z_ = z_ * scale;

	return result;
}

//---------------------------------------------------------------------------
//! スケーリング
//---------------------------------------------------------------------------
Vector3 Vector3::operator/(f32 scale) const
{
	Vector3 result;
	f32     invScale = 1.0f / scale;
	result.x_ = x_ * invScale;
	result.y_ = y_ * invScale;
	result.z_ = z_ * invScale;

	return result;
}

//---------------------------------------------------------------------------
//! 加算
//---------------------------------------------------------------------------
Vector3& Vector3::operator+=(const Vector3& v)
{
	x_ += v.x_;
	y_ += v.y_;
	z_ += v.z_;

	return *this;
}

//---------------------------------------------------------------------------
//! 減算
//---------------------------------------------------------------------------
Vector3& Vector3::operator-=(const Vector3& v)
{
	x_ -= v.x_;
	y_ -= v.y_;
	z_ -= v.z_;

	return *this;
}

//---------------------------------------------------------------------------
//! スケーリング
//---------------------------------------------------------------------------
Vector3& Vector3::operator*=(f32 scale)
{
	x_ *= scale;
	y_ *= scale;
	z_ *= scale;

	return *this;
}

//---------------------------------------------------------------------------
//! スケーリング
//---------------------------------------------------------------------------
Vector3& Vector3::operator/=(f32 scale)
{
	f32 invScale = 1.0f / scale;

	return operator*=(invScale);
}

//---------------------------------------------------------------------------
//! 比較
//---------------------------------------------------------------------------
bool Vector3::operator==(const Vector3& v)
{
	if (x_ == v.x_ &&
		y_ == v.y_ &&
		z_ == v.z_) {
		return true;
	}
	return false;
}

//---------------------------------------------------------------------------
//! 長さの２乗
//---------------------------------------------------------------------------
f32 Vector3::lengthSq() const
{
	return x_ * x_ + y_ * y_ + z_ * z_;
}

//---------------------------------------------------------------------------
//! ベクトルの長さ
//---------------------------------------------------------------------------
f32 Vector3::length() const
{
	f32 L = lengthSq();   // 長さの二乗
	if (L == 0.0f) {
		return 0.0f;
	}
	return sqrtf(L);
}

//---------------------------------------------------------------------------
//! 正規化
//---------------------------------------------------------------------------
Vector3 Vector3::normalize() const
{
	f32 L = lengthSq();   // 長さの2乗を求める

	// 長さが0.0なら自分自身のベクトルの長さは0.0になっている。
	if (L == 0.0f) {
		return *this;
	}
	return *this / sqrtf(L);
}

//---------------------------------------------------------------------------
//!	内積
//---------------------------------------------------------------------------
f32 Vector3::dot(Vector3 a, Vector3 b)
{
	return (a.x_ * b.x_) + (a.y_ * b.y_) + (a.z_ * b.z_);
}

//---------------------------------------------------------------------------
//!	外積
//---------------------------------------------------------------------------
Vector3 Vector3::cross(Vector3 a, Vector3 b)
{
	Vector3 result;

	result.x_ = (a.y_ * b.z_) - (a.z_ * b.y_);
	result.y_ = (a.z_ * b.x_) - (a.x_ * b.z_);
	result.z_ = (a.x_ * b.y_) - (a.y_ * b.x_);

	return result;
}

//---------------------------------------------------------------------------
//! 座標変換(平行移動あり)
//---------------------------------------------------------------------------
Vector4 Vector3::transform(const Matrix& matrix)
{
	Vector4 result;

	result.x_ = (x_ * matrix.m_[0][0]) +
		(y_ * matrix.m_[1][0]) +
		(z_ * matrix.m_[2][0]) +
		(matrix.m_[3][0]);

	result.y_ = (x_ * matrix.m_[0][1]) +
		(y_ * matrix.m_[1][1]) +
		(z_ * matrix.m_[2][1]) +
		(matrix.m_[3][1]);

	result.z_ = (x_ * matrix.m_[0][2]) +
		(y_ * matrix.m_[1][2]) +
		(z_ * matrix.m_[2][2]) +
		(matrix.m_[3][2]);

	result.w_ = (x_ * matrix.m_[0][3]) +
		(y_ * matrix.m_[1][3]) +
		(z_ * matrix.m_[2][3]) +
		(matrix.m_[3][3]);

	return result;
}

//---------------------------------------------------------------------------
//! 座標変換(ベクトルの回転。平行移動なし)
//---------------------------------------------------------------------------
Vector3 Vector3::transformNormal(const Matrix& matrix)
{
	Vector3 result;

	result.x_ = (x_ * matrix.m_[0][0]) +
		(y_ * matrix.m_[1][0]) +
		(z_ * matrix.m_[2][0]);

	result.y_ = (x_ * matrix.m_[0][1]) +
		(y_ * matrix.m_[1][1]) +
		(z_ * matrix.m_[2][1]);

	result.z_ = (x_ * matrix.m_[0][2]) +
		(y_ * matrix.m_[1][2]) +
		(z_ * matrix.m_[2][2]);

	return result;
}

//===========================================================================
//!	4要素ベクトル構造体
//===========================================================================

const Vector4 Vector4::ZERO(0.0f, 0.0f, 0.0f, 0.0f);
const Vector4 Vector4::ONE(1.0f, 1.0f, 1.0f, 1.0f);

//---------------------------------------------------------------------------
//! 代入(Vector3)
//---------------------------------------------------------------------------
Vector4& Vector4::operator=(const Vector3& v)
{
	x_ = v.x_;
	y_ = v.y_;
	z_ = v.z_;
	w_ = 1.0f;

	return *this;
}